using Foundation.Enumerators.Exceptions;
using Foundation.Exceptions.Managers;
using Foundation.Models;
using Foundation.Models.Schemes;

using System.Runtime.CompilerServices;
using System.Text.Json;

namespace Foundation.Managers;
public class DatasourceConnectionManager {
    private const string DirectoryName = "Connection";
    private const string QualityPrefix = "quality_";
    private const string DevelopmentPrefix = "development_";

    /// <summary>
    ///     Fetches and loads through IO functionallities for private file based secret
    ///     connection properties for Datasources connections handlers. 
    ///     Then build it and validate it to generate a Model.
    ///     
    ///     RECOMMENDED: Check the parameter documentation to ensure the correct use.
    /// </summary>
    /// <param name="callerPath"> 
    ///     Automatically gets the path of the method caller through execution-time assemblies access
    ///     attribute decorator, this is correctly calculated when the method is called
    ///     directly in the Datasource context class that is generated by the EF CLI tools when 
    ///     migrated a database configuration, otherwise can struggle with the correct project 
    ///     file leveling generation. 
    ///     In that kind of cases this parameter can be overwritten by the caller to inject
    ///     the correct datasource project root path.
    /// </param>
    /// <returns>
    ///     <see cref="DatasourceConnectionModel"/>: The datasource connection properties gathered and retrieved from the found private properties file.
    /// </returns>
    /// <exception cref="XDatasourceConnectionLoad">
    ///     When something gone wrong during the IO connection properties gather operation.
    /// </exception>
    public static DatasourceConnectionModel Load([CallerFilePath] string? callerPath = null) {
        string prefix = EnvironmentManager.Mode switch {
            Enumerators.Managers.EnvironmentModes.development => DevelopmentPrefix,
            Enumerators.Managers.EnvironmentModes.quality => QualityPrefix,
            _ => DevelopmentPrefix,
        };
        string propertiesFileName = $"{prefix}connection.json";

        if (callerPath is null) 
            throw new XDatasourceConnectionLoad(ConnectionLoadFailureReasons.CallerPathEmpty, propertiesFileName);

        DirectoryInfo? parentProjectDirInfo = Directory.GetParent(callerPath);
        if(parentProjectDirInfo is null)
            throw new XDatasourceConnectionLoad(ConnectionLoadFailureReasons.ParentProjectPathEmpty, propertiesFileName);

        IEnumerable<DirectoryInfo> projectDirectories = parentProjectDirInfo.EnumerateDirectories();
        DirectoryInfo? connectionPropertiesDirectory = projectDirectories
            .Where(i => i.Name == DirectoryName)
            .FirstOrDefault();
        if(connectionPropertiesDirectory is null)
            throw new XDatasourceConnectionLoad(ConnectionLoadFailureReasons.ConnectionDirectoryUnfound, propertiesFileName);

        FileInfo? connectionPropertiesFileInfo = connectionPropertiesDirectory.GetFiles()
            .Where(i => i.Name == propertiesFileName)
            .FirstOrDefault();
        if (connectionPropertiesFileInfo is null)
            throw new XDatasourceConnectionLoad(ConnectionLoadFailureReasons.ConnectionPropertiesUnfound, propertiesFileName);

        DatasourceConnectionScheme? Scheme;
        try {
            using FileStream propertiesFileStream = new(connectionPropertiesFileInfo.FullName, FileMode.Open, FileAccess.Read, FileShare.Read);
            Scheme = JsonSerializer.Deserialize<DatasourceConnectionScheme>(propertiesFileStream);
            propertiesFileStream.Dispose();

            if (Scheme is null)
                throw new XDatasourceConnectionLoad(ConnectionLoadFailureReasons.WrongPropertiesFileFormat, propertiesFileName);
        } catch(Exception ex) {
            throw new XDatasourceConnectionLoad(ConnectionLoadFailureReasons.IOCriticalException, propertiesFileName, ex);
        }

        DatasourceConnectionModel Model = Scheme.GenerateModel();
        return Model;
    }
}
